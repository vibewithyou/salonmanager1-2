import { useEffect, useState } from 'react';
import { supabase } from '@/integrations/supabase/client';

/**
 * Represents a customer profile record stored in the database. A profile
 * belongs to a salon and may optionally reference a registered user via
 * `user_id`. All fields besides `id` and `salon_id` are nullable to
 * accommodate incomplete data when creating manual customer files.
 */
export interface CustomerProfile {
  id: string;
  salon_id: string;
  user_id: string | null;
  first_name: string;
  last_name: string;
  birthdate: string | null;
  phone: string | null;
  email: string | null;
  address: string | null;
  image_urls: string[] | null;
  notes: string | null;
  created_at: string;
  updated_at: string;
}

/**
 * Hook to fetch and manage customer profiles for a particular salon. The
 * caller must provide a valid `salonId`. The hook exposes functions to
 * create, update and delete customer records as well as to fetch past
 * appointments for a given customer. Appointments are limited to the
 * previous five years and include service details for convenience.
 */
export function useCustomers(salonId: string | undefined | null) {
  const [customers, setCustomers] = useState<CustomerProfile[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    async function fetchCustomers() {
      if (!salonId) {
        setCustomers([]);
        setLoading(false);
        return;
      }
      setLoading(true);
      const { data, error } = await supabase
        .from('customer_profiles')
        .select('*')
        .eq('salon_id', salonId)
        .order('last_name', { ascending: true });
      if (error) {
        setError(error.message);
      } else {
        setCustomers((data as CustomerProfile[]) || []);
        setError(null);
      }
      setLoading(false);
    }
    fetchCustomers();
  }, [salonId]);

  /**
   * Create a new customer profile. Accepts a partial profile without
   * id/created_at/updated_at; those fields are generated by the database.
   */
  async function createCustomer(profile: Omit<CustomerProfile, 'id' | 'created_at' | 'updated_at'>) {
    const { data, error } = await supabase
      .from('customer_profiles')
      .insert(profile)
      .select()
      .single();
    if (error) {
      throw error;
    }
    setCustomers((prev) => [...prev, data as CustomerProfile]);
    return data as CustomerProfile;
  }

  /**
   * Update an existing customer profile. Only the provided fields will be
   * updated. Returns the updated record.
   */
  async function updateCustomer(id: string, updates: Partial<CustomerProfile>) {
    const { data, error } = await supabase
      .from('customer_profiles')
      .update(updates)
      .eq('id', id)
      .select()
      .single();
    if (error) {
      throw error;
    }
    setCustomers((prev) => prev.map((c) => (c.id === id ? (data as CustomerProfile) : c)));
    return data as CustomerProfile;
  }

  /**
   * Delete a customer profile by id. Removes the entry from the local state
   * upon successful deletion.
   */
  async function deleteCustomer(id: string) {
    const { error } = await supabase
      .from('customer_profiles')
      .delete()
      .eq('id', id);
    if (error) {
      throw error;
    }
    setCustomers((prev) => prev.filter((c) => c.id !== id));
  }

  /**
   * Fetch past appointments for a given customer profile. Appointments are
   * limited to the previous five years and sorted by start_time descending.
   * Service details are included via foreign table join.
   */
  async function getCustomerAppointments(customerId: string) {
    const fiveYearsAgo = new Date();
    fiveYearsAgo.setFullYear(fiveYearsAgo.getFullYear() - 5);
    const { data, error } = await supabase
      .from('appointments')
      .select('id, start_time, end_time, status, notes, guest_name, guest_email, guest_phone, price, buffer_before, buffer_after, image_url, service:services(name, duration_minutes, price)')
      .eq('customer_profile_id', customerId)
      .gte('start_time', fiveYearsAgo.toISOString())
      .order('start_time', { ascending: false });
    if (error) {
      throw error;
    }
    return data || [];
  }

  return {
    customers,
    loading,
    error,
    createCustomer,
    updateCustomer,
    deleteCustomer,
    getCustomerAppointments,
  };
}